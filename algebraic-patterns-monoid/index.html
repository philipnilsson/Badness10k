<!DOCTYPE html>
 <html lang="en"><head><script type="text/javascript" async="" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><script async="" src="//platform.twitter.com/widgets.js"></script><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title data-react-helmet="true">Badness 10.0000 | Algebraic patterns — Monoid</title><style id="typography.js">html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{font:125%/1.65em Alegreya,serif;box-sizing:border-box;overflow-y:scroll;}*{box-sizing:inherit;}*:before{box-sizing:inherit;}*:after{box-sizing:inherit;}body{color:hsla(0,0%,0%,0.8);font-family:Alegreya,serif;font-weight:normal;word-wrap:break-word;font-kerning:normal;-moz-font-feature-settings:"kern", "liga", "clig", "calt";-ms-font-feature-settings:"kern", "liga", "clig", "calt";-webkit-font-feature-settings:"kern", "liga", "clig", "calt";font-feature-settings:"kern", "liga", "clig", "calt";}img{max-width:100%;margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.65rem;}h1{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.65rem;color:inherit;font-family:Patua One,serif;font-weight:bold;text-rendering:optimizeLegibility;font-size:2.25rem;line-height:2.475rem;}h2{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.65rem;color:inherit;font-family:Patua One,serif;font-weight:bold;text-rendering:optimizeLegibility;font-size:1.62671rem;line-height:2.475rem;}h3{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.65rem;color:inherit;font-family:Patua One,serif;font-weight:bold;text-rendering:optimizeLegibility;font-size:1.38316rem;line-height:1.65rem;}h4{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.65rem;color:inherit;font-family:Patua One,serif;font-weight:bold;text-rendering:optimizeLegibility;font-size:1rem;line-height:1.65rem;}h5{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.65rem;color:inherit;font-family:Patua One,serif;font-weight:bold;text-rendering:optimizeLegibility;font-size:0.85028rem;line-height:1.65rem;}h6{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.65rem;color:inherit;font-family:Patua One,serif;font-weight:bold;text-rendering:optimizeLegibility;font-size:0.78405rem;line-height:1.65rem;}hgroup{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.65rem;}ul{margin-left:1.65rem;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.65rem;list-style-position:outside;list-style-image:none;}ol{margin-left:1.65rem;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.65rem;list-style-position:outside;list-style-image:none;}dl{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.65rem;}dd{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.65rem;}p{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.65rem;}figure{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.65rem;}pre{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.65rem;font-size:0.85rem;line-height:1.42;background:hsla(0,0%,0%,0.04);border-radius:3px;overflow:auto;word-wrap:normal;padding:1.65rem;}table{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.65rem;font-size:1rem;line-height:1.65rem;border-collapse:collapse;width:100%;}fieldset{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.65rem;}blockquote{margin-left:1.65rem;margin-right:1.65rem;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.65rem;}form{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.65rem;}noscript{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.65rem;}iframe{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.65rem;}hr{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:calc(1.65rem - 1px);background:hsla(0,0%,0%,0.2);border:none;height:1px;}address{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.65rem;}b{font-weight:bold;}strong{font-weight:bold;}dt{font-weight:bold;}th{font-weight:bold;}li{margin-bottom:calc(1.65rem / 2);}ol li{padding-left:0;}ul li{padding-left:0;}li > ol{margin-left:1.65rem;margin-bottom:calc(1.65rem / 2);margin-top:calc(1.65rem / 2);}li > ul{margin-left:1.65rem;margin-bottom:calc(1.65rem / 2);margin-top:calc(1.65rem / 2);}blockquote *:last-child{margin-bottom:0;}li *:last-child{margin-bottom:0;}p *:last-child{margin-bottom:0;}li > p{margin-bottom:calc(1.65rem / 2);}code{font-size:0.85rem;line-height:1.65rem;}kbd{font-size:0.85rem;line-height:1.65rem;}samp{font-size:0.85rem;line-height:1.65rem;}abbr{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;}acronym{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;}abbr[title]{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;text-decoration:none;}thead{text-align:left;}td,th{text-align:left;border-bottom:1px solid hsla(0,0%,0%,0.12);font-feature-settings:"tnum";-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";padding-left:1.1rem;padding-right:1.1rem;padding-top:0.825rem;padding-bottom:calc(0.825rem - 1px);}th:first-child,td:first-child{padding-left:0;}th:last-child,td:last-child{padding-right:0;}tt,code{background-color:hsla(0,0%,0%,0.04);border-radius:3px;font-family:"SFMono-Regular", Consolas,"Roboto Mono","Droid Sans Mono","Liberation Mono",Menlo,Courier,monospace;padding:0;padding-top:0.2em;padding-bottom:0.2em;}pre code{background:none;line-height:1.42;}code:before,code:after,tt:before,tt:after{letter-spacing:-0.2em;content:" ";}pre code:before,pre code:after,pre tt:before,pre tt:after{content:"";}</style><link href="//fonts.googleapis.com/css?family=Patua+One:400|Alegreya:400,400i,700" rel="stylesheet" type="text/css"/><style>.warning{color:#9f6000;background-color:#feefb3;padding:18px}.warning:before{content:"\26A0";margin-right:9px}.rfc-page pre{font-family:inherit}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}h1,h2,h3,h4{font-weight:400}.header{text-align:center;padding:4em 0}.header h1{margin-bottom:.3em}.markdown img{max-width:400px;max-width:25rem}.headroom-wrapper h2{margin:0;padding:0;text-transform:uppercase;color:#fff}.headroom-wrapper{height:inherit!important}.figure{text-align:center}#footer{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;padding:1em 0;-webkit-box-align:center;-ms-flex-align:center;align-items:center}#footer a{font-size:80%;padding-bottom:.8em}</style></head><body><div id="react-mount"><div data-reactroot="" data-reactid="1" data-react-checksum="500901853"><div style="margin-bottom:1.65rem;" class="headroom-wrapper" data-reactid="2"><div style="position:relative;top:0;left:0;right:0;z-index:1;-webkit-transform:translateY(0);-ms-transform:translateY(0);transform:translateY(0);background:#1244ee;" class="headroom headroom--unfixed" data-reactid="3"><div style="max-width:40rem;margin-left:auto;margin-right:auto;padding-top:0;padding:0.825rem 1.2375rem;" data-reactid="4"><a style="color:black;text-decoration:none;" href="/Badness10k/" data-reactid="5"><h2 style="float:left;" data-reactid="6">Badness 10.000</h2><a class="twitter-bird" href="//www.twitter.com/ali_pang" style="float:right;" data-reactid="7"><img src="https://g.twimg.com/dev/documentation/image/Twitter_logo_blue_48.png" style="margin:0px;filter:brightness(4);max-height:2.1rem;" data-reactid="8"/></a></a><span style="display:block;clear:both;" data-reactid="9"> </span></div></div></div><div style="max-width:40rem;margin-left:auto;margin-right:auto;padding:1.65rem 1.2375rem;padding-top:0;" data-reactid="10"><div class="markdown" data-reactid="11"><!-- react-empty: 12 --><div class="header" data-reactid="13"><h1 data-reactid="14">Algebraic patterns — Monoid</h1><span data-reactid="15"><!-- react-text: 16 -->Posted on <!-- /react-text --><!-- react-text: 17 -->July 21, 2016<!-- /react-text --></span></div><div data-reactid="18"><h2>Definition</h2>
<p>The <strong>Monoid</strong> pattern is simply the combination of the two patterns
<a href="/2016-06-29-functional-patterns-identity-element.html">Identity Element</a>
and <a href="/2016-07-14-functional-patterns-semigroup.html">Semigroup</a>. A
monoid therefore is a datatype with composition <code>⊗</code> and element <code>e</code>,
satisfying</p>
<pre><code><span class="hljs-keyword">x</span> ⊗ e = <span class="hljs-keyword">x</span>
e ⊗ <span class="hljs-keyword">x</span> = <span class="hljs-keyword">x</span>
<span class="hljs-keyword">x</span> ⊗ (y ⊗ z) = (<span class="hljs-keyword">x</span> ⊗ y) ⊗ z
</code></pre>
<p>Some understanding of these patterns is assumed in this article. If
you feel like you need intuition on what these equations mean, read
the entries on these individual patterns before continuing.</p>
<h2>Intuition</h2>
<p>The monoid pattern models the many structures that are semigroups and
also have identity elements. In such situations, it is often
convenient to consider these patterns in concert in order to derive
elegant models and laws.</p>
<p>For instance the semigroup of lists have the empty list <code>[]</code> as
identity. Treating lists as a semigroup <em>only</em> often result in less
elegant laws where the empty list has to be treated as a separate
case.</p>
<p>In this article we’ll give some examples of monoids and develop some
models suitable for problem solving in <em>Map-Reduce</em> style
programming models.</p>
<p><h3> Notation </h3></p>
<p>To refer to a particular monoid we take the triple of its type,
composition and identity. For instance <code>(Number, +, 0)</code> is the monoid
of numbers with addition.</p>
<p><h3>Folds</h3></p>
<p>For any monoid we can define a function called <code>fold</code>. It takes a list
of elements of that monoid to their “product”. For the monoid
<code>(Number, +, 0)</code>, we define <code>fold</code> (by example) as</p>
<pre><code>fold([]) = <span class="hljs-number">0</span>
fold([<span class="hljs-number">1</span>]) = <span class="hljs-number">1</span>
fold([<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>])
  = <span class="hljs-number">5</span> + <span class="hljs-number">6</span> + <span class="hljs-number">3</span> + <span class="hljs-number">1</span>
  = <span class="hljs-number">15</span>
</code></pre>
<p>The <code>fold</code> function simply inserts the monoid composition (in our case
<code>+</code>) between each element. For the empty list it returns the identity
element (<code>0</code>). The <code>fold</code> for the monoid <code>(Number, +, 0)</code> then is
just the <code>sum</code> function.</p>
<hr>
<p>Let’s repeat the construction above with a different monoid,
<code>(Number, max, -∞)</code>. In this case we get</p>
<pre><code>fold([]) = -Infinity
fold([<span class="hljs-number">10</span>]) = <span class="hljs-number">10</span>
fold([<span class="hljs-number">9</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">12</span>])
  = <span class="hljs-number">9</span> max <span class="hljs-number">6</span> max <span class="hljs-number">5</span> max <span class="hljs-number">12</span>
  = <span class="hljs-number">12</span>
</code></pre>
<p>so the <code>fold</code> for this monoid is the <code>maximum</code> function which finds
the largest element in a list, and returns its identity <code>-∞</code> for the
empty list.</p>
<hr>
<p>For the boolean monoid <code>(Bool, &amp;&amp;)</code> <code>fold</code> is the <code>every</code> function</p>
<pre><code><span class="hljs-string">fold([true,</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span> <span class="hljs-literal">true</span><span class="hljs-string">])</span>
  <span class="hljs-string">=</span> <span class="hljs-literal">true</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-literal">false</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-literal">true</span>
  <span class="hljs-string">=</span> <span class="hljs-literal">false</span>
<span class="hljs-string">fold([])</span> <span class="hljs-string">=</span> <span class="hljs-literal">true</span>
</code></pre>
<p>which checks if all elements in a list are true.</p>
<p>and for <code>(Bool, ||)</code> we get the <code>some</code> function</p>
<pre><code><span class="hljs-string">fold([true,</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span> <span class="hljs-literal">true</span><span class="hljs-string">])</span>
  <span class="hljs-string">=</span> <span class="hljs-literal">true</span> <span class="hljs-string">||</span> <span class="hljs-literal">false</span> <span class="hljs-string">||</span> <span class="hljs-literal">true</span>
  <span class="hljs-string">=</span> <span class="hljs-literal">true</span>
<span class="hljs-string">fold([])</span> <span class="hljs-string">=</span> <span class="hljs-literal">false</span>
</code></pre>
<p>which checks if some element is true.</p>
<hr>
<p>Another two interesting examples of folds are the <code>head</code> and <code>last</code>
functions that find the first and last element of a list
respectively. These arise out of the semigroup operations <code>⨮</code> and <code>⨭</code>
defined as.</p>
<pre><code><span class="hljs-keyword">x</span> ⨭ y = <span class="hljs-keyword">x</span>
<span class="hljs-keyword">x</span> ⨮ y = y
</code></pre>
<p>which simply discard one of their arguments.</p>
<p><code>head</code> then is the function</p>
<pre><code>fold([x, y, z])
  =<span class="ruby"> x ⨭ y ⨭ z
</span>  =<span class="ruby"> x
</span></code></pre>
<p>and <code>last</code> is the function</p>
<pre><code>fold([x, y, z])
  =<span class="ruby"> x ⨮ y ⨮ z
</span>  =<span class="ruby"> z
</span></code></pre>
<p>Unfortunately we can not give meaning to the expression
<code>fold([])</code>. This is because <code>⨮</code> and <code>⨭</code> define semigroups that are not
monoids, so these functions err on the empty list. This illustrates
the problem of working with semigroups only, when our domain of study
are lists.</p>
<p><h3> Algebra for parallelism </h3></p>
<p>The relation of <code>folds</code> to the map-reduce programming model and
parallel computation in general can be captured in the fact that they
satisfy the following <em>distributive law</em>.</p>
<pre><code><span class="hljs-built_in">fold</span>(xs ++ ys) = <span class="hljs-built_in">fold</span>(xs) ⊗ <span class="hljs-built_in">fold</span>(ys)
</code></pre>
<p>For a list that is the concatenation of lists <code>xs</code> and <code>ys</code>,
<code>fold(xs)</code> and <code>fold(ys)</code> could be computed on different machines, or
CPU cores, so such a law is a suitable condition for when a problem
can be solved in a distributed or parallel way. At the end the two
partial solutions are re-combined using the monoid composition <code>⊗</code>,
and this law then states that this behaves <em>“as if the problem was
solved sequentially”</em>, by folding the entire list in sequence.</p>
<p>Since <code>sum</code> and <code>maximum</code> are both folds, they can be computed in
parallel. The distributive law is these cases become</p>
<pre><code>sum([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])
  = sum([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] ++ [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])
  = sum([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) + sum([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])

maximum([<span class="hljs-number">9</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">12</span>])
  = maximum([<span class="hljs-number">9</span>, <span class="hljs-number">6</span>] ++ [<span class="hljs-number">5</span>, <span class="hljs-number">12</span>])
  = maximum([<span class="hljs-number">9</span>, <span class="hljs-number">6</span>]) `max` maximum([<span class="hljs-number">5</span>, <span class="hljs-number">12</span>])
</code></pre>
<p>Of course, such a law can be repeatedly applied</p>
<pre><code>sum([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]) =
sum([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]) + sum([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]) =
sum([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]) + sum([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]) + sum([<span class="hljs-number">5</span>, <span class="hljs-number">6</span>])
</code></pre>
<p>to distribute such a problem to any number of machines or cores.</p>
<p>Note that the requirement for an identity element arises
naturally out of such a law:</p>
<pre><code>fold(<span class="hljs-name">xs</span>) = fold(<span class="hljs-name">xs</span> ++ []) = fold(<span class="hljs-name">xs</span>) ++ fold([])
fold(<span class="hljs-name">xs</span>) = fold([] ++ xs) = fold([]) = fold(<span class="hljs-name">xs</span>)
</code></pre>
<p>the value <code>fold([])</code> must be such that it is an identity element for
the range of <code>fold</code>, providing further evidence that the concept of a
monoid is a natural extension of that of a semigroup when dealing with
possibly empty lists.</p>
<p>The distributive law above is the fundamental property exploited in
the map-reduce model, but <code>fold</code>s do <em>not</em> cover all functions that can
be solved in this way. To provide a better classification we generalize.</p>
<h2>Monoid morphisms</h2>
<p>To define the concept of a monoid morphism, we pair the distributive
law mentioned above with <code>fold</code>s behaviour on the empty list, which by
defintion returns the empty element of the target monoid.</p>
<pre><code><span class="hljs-function"><span class="hljs-title">fold</span><span class="hljs-params">([])</span></span> = e
<span class="hljs-function"><span class="hljs-title">fold</span><span class="hljs-params">(xs ++ ys)</span></span> = fold(xs) ⊗ fold(ys)
</code></pre>
<p>We say that <code>fold</code>s <em>respects monoid structure</em>, because they map the
identity element of lists (<code>[]</code>) to identity elements in their
domains(<code>e</code>), and they map monoid compositions (<code>++</code>) to
compositions in the target monoid (<code>⊗</code>).</p>
<p>A function that respects monoid structure is called a <strong>monoid
morphism</strong>. Folds then, are monoid morphisms <em>from</em> the list monoid to
another.</p>
<p>In general, monoid morphisms need not be from the list monoid. In general
<code>h</code> is a monoid morphism if it satisfies</p>
<pre><code>h<span class="hljs-comment">(e)</span> = f
h<span class="hljs-comment">(a ⊕ b)</span> = h<span class="hljs-comment">(a)</span> ⊗ h<span class="hljs-comment">(b)</span>
</code></pre>
<p>for some source monoid <code>(M, e, ⊕)</code> to a target monoid <code>(N, f, ⊗)</code>.</p>
<hr>
<p>As we have seen <code>sum</code> is a fold and thus a monoid morphism, in this
case targetting the monoid of numbers with addition. Another morphism
with the same target monoid is <code>length</code>. It is a monoid morphism as it
also respects monoid structure.</p>
<pre><code>length([]) = <span class="hljs-number">0</span>
length(<span class="hljs-name">xs</span> ++ ys) = length(<span class="hljs-name">xs</span>) + length(<span class="hljs-name">ys</span>)
</code></pre>
<p>Length is of course also another example of a function that is
computable in parallel (albeit not a very interesting one). It is not
a <code>fold</code> however, and doesn’t even “type-check” as such.</p>
<hr>
<p>For some list, e.g. <code>[4, 6, 1]</code>, we can apply the
distributive laws for <code>sum</code> and <code>length</code> over and over until we
get to single-element lists.</p>
<pre><code>sum([<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>]) = sum([<span class="hljs-number">4</span>]) + sum([<span class="hljs-number">6</span>]) + sum([<span class="hljs-number">1</span>])
length([<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>]) = length([<span class="hljs-number">4</span>]) + length([<span class="hljs-number">6</span>]) + length([<span class="hljs-number">1</span>])
</code></pre>
<p>We can always make an argument of this type. It must then be the case
that the difference between <code>sum</code> and <code>length</code> is only really in how
they behave on single-element lists.</p>
<pre><code><span class="hljs-function"><span class="hljs-title">sum</span><span class="hljs-params">([x])</span></span> = x
<span class="hljs-function"><span class="hljs-title">length</span><span class="hljs-params">([x])</span></span> = <span class="hljs-number">1</span>
</code></pre>
<p>As there is nothing special about <code>sum</code> or <code>length</code> we can
generalize:</p>
<p><strong>Theorem</strong> A monoid morphism from lists is determined uniquely by
its target monoid and its behaviour on single-element lists.</p>
<hr>
<p>A monoid morphism that both starts and ends in the list monoid, is
<code>map(f)</code>, the higher-order function that maps a function <code>f</code> over
each element of a list.</p>
<pre><code><span class="hljs-function"><span class="hljs-title">map</span><span class="hljs-params">(f)</span><span class="hljs-params">([])</span> = []
<span class="hljs-title">map</span><span class="hljs-params">(f)</span><span class="hljs-params">(xs ++ ys)</span> = <span class="hljs-title">map</span><span class="hljs-params">(f)</span><span class="hljs-params">(xs)</span> ++ <span class="hljs-title">map</span><span class="hljs-params">(f)</span><span class="hljs-params">(ys)</span>
</span></code></pre>
<p><code>map(f)</code> is thus another parallelizable function, that also happen to
be a monoid morphism. By our previous discussion, it also possible to
define <code>map(f)</code> as the unique monoid morphism from lists to lists
satisfying</p>
<pre><code><span class="hljs-function"><span class="hljs-title">map</span><span class="hljs-params">(f)</span><span class="hljs-params">([x])</span></span> = [f(x)]
</code></pre>
<p>Since any possible behaviour on single element lists can be
expressed by some function <code>f</code>, we see that.</p>
<p><strong>Theorem</strong> Any monoid morphism from lists can be written on the
form</p>
<pre><code><span class="hljs-keyword">fold</span> ∘ <span class="hljs-keyword">map</span>(<span class="hljs-keyword">f</span>)
</code></pre>
<p>for some function <code>f</code>, clearly providing some validity to <em>Map-Reduce</em>
as a computational model — it covers completely the set of functions
&quot;naturally&quot; parallelizable through the distributive law defining
monoid morphisms.</p>
<hr>
<p>There is a way to extend <em>any</em> semigroup <code>(S, ⊗)</code> into a monoid. We
simply add to its underlying type another value, that we’ll call
<code>None</code>. It’s composition will be the same as <code>⊗</code>, except for if either
side is <code>None</code>, in which case we’ll make <code>None</code> an identity by defintion.</p>
<pre><code>None ⊗₊ <span class="hljs-keyword">x</span> = <span class="hljs-keyword">x</span>
<span class="hljs-keyword">x</span> ⊗₊ None = <span class="hljs-keyword">x</span>
<span class="hljs-keyword">x</span> ⊗₊ y = <span class="hljs-keyword">x</span> ⊗ y  // otherwise
</code></pre>
<p>This construction is simply the <code>Option</code> or <code>Maybe</code> type, along with a
suitably defined monoid structure.</p>
<p>Now we can define <code>safeHead</code> and <code>safeLast</code> as the folds of <code>⨭₊</code> and
<code>⨮₊</code>. For instance <code>safeHead</code> is the fold</p>
<pre><code>fold([]) = None
fold([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
  = <span class="hljs-number">1</span> ⨭₊ <span class="hljs-number">2</span> ⨭₊ <span class="hljs-number">3</span>
  = <span class="hljs-number">1</span>
</code></pre>
<p>Creating “safe” functions on lists can be seen as correcting a
mismatch in structure between lists (that are monoids), and semigroups
(that are not).</p>
<p>The fact that we chose <code>maximum([]) = -Infinity</code> is a
similar correction, in fact it is of exactly the same form, except we
named <code>None</code> as <code>-Infinity</code>.</p>
<hr>
<p>Functions and maps are monoids if their domain is a monoid, where
composition is performed pointwise.</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">composeFunctions</span>(<span class="hljs-params">f,g</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> f(x) ⊗ g(x);
}
</code></pre>
<p>we call this the pointwise lifting of the monoid over the range.</p>
<p>Frequency maps are an example of this construction, they are the pointwise
lifted additive monoid on numbers <code>(Number, + 0)</code>.</p>
<p><strong>Exercise</strong> Consider the semigroup of the set <code>{ LESS, GREATER }</code> with
composition <code>⨮</code>. Define the monoid of comparators starting with this
semigroup, and using the <code>Option</code> and pointwise lifting constructions.</p>
<p><strong>Exercise</strong> Counting the votes in an election is a good real-word
example of a parallelizable problem. Define a monoid morphism from a
list of votes to some monoid giving the election results. Define the target
monoid as the pointwise lift of another monoid.</p>
<p><strong>Exercise</strong> Show that the fundamental theorem of arithmetic induces a
monoid morphism from <code>(Number, *, 1)</code> to the monoid <code>(Number, +, 0)</code>
lifted pointwise over the prime numbers.</p>
</div></div><div id="footer" data-reactid="19"><a type="application/rss+xml" href="http://philipnilsson.github.io/Badness10k/atom.xml" data-reactid="20">RSS feed for this page</a><a href="https://twitter.com/ali_pang" class="twitter-follow-button" data-show-count="false" data-size="large" data-reactid="21">Follow @ali_pang</a></div><div id="disqus_thread" data-reactid="22"></div><span style="display:block;clear:both;" data-reactid="23"> </span></div></div></div><script src="/Badness10k/bundle.js?t=1498570652009"></script></body></html>